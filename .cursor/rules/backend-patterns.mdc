---
globs: backend/**/*.py,*.py
description: Backend FastAPI patterns and structure guide
---

# Backend Development Patterns

## FastAPI Application Structure

The backend follows a layered architecture pattern with clear separation of concerns:

```
backend/src/
├── main.py                 # FastAPI app entry point
├── api/
│   ├── routers/           # API route handlers
│   │   ├── sightings.py   # Sighting management endpoints
│   │   ├── ringings.py    # Ringing management endpoints
│   │   ├── analytics.py   # Analytics and reporting endpoints
│   │   ├── family.py      # Family relationship endpoints
│   │   └── ...
│   └── services/          # Business logic layer
├── database/
│   ├── connection.py      # Database session management
│   ├── models.py          # SQLAlchemy ORM models
│   ├── family_models.py   # Family relationship models
│   ├── repositories.py    # Data access layer
│   └── family_repository.py # Family-specific data access
└── utils/
    ├── logging_config.py  # Logging configuration
    ├── cache.py          # Caching utilities
    └── distance.py       # Geographic calculations
```

## Development Patterns

### Dependency Management

- Use `uv` for Python package management
- Dependencies defined in [pyproject.toml](mdc:backend/pyproject.toml)
- Test dependencies in optional `[test]` group

### Database Patterns

- **Session Management**: Use `get_db()` dependency for database sessions
- **Models**: SQLAlchemy ORM models in [database/models.py](mdc:backend/src/database/models.py)
- **Repositories**: Data access layer pattern for complex queries
- **Migrations**: SQL migration files in [database/migrations/](mdc:backend/database/migrations/)

### API Router Pattern

```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from ..database.connection import get_db

router = APIRouter(prefix="/endpoint", tags=["endpoint"])

@router.get("/")
def get_items(db: Session = Depends(get_db)):
    # Implementation
    pass
```

### Error Handling

- Use FastAPI's built-in exception handling
- Return appropriate HTTP status codes
- Include meaningful error messages

### Testing

- Tests located in [tests/](mdc:backend/tests/)
- Use pytest with async support
- Test configuration in [pyproject.toml](mdc:backend/pyproject.toml)
- Run tests: `uv run pytest`

### Logging

- Centralized logging configuration in [utils/logging_config.py](mdc:backend/src/utils/logging_config.py)
- Environment-based log levels
- Request logging middleware available

## Key Components

### Main Application

Entry point: [src/main.py](mdc:backend/src/main.py)

- FastAPI app initialization
- CORS middleware configuration
- Router registration
- Database table creation

### Database Models

Primary models in [database/models.py](mdc:backend/src/database/models.py):

- `Sighting`: Bird observation records
- `Ringing`: Bird ringing information
- `FamilyTreeEntry`: Family relationships

Family models in [database/family_models.py](mdc:backend/src/database/family_models.py):

- `BirdRelationship`: Relationship management
- `RelationshipType`: Enum for relationship types

#### Family Relationship Enum Conversion Pattern

**CRITICAL**: The family relationships API uses a specific enum conversion pattern due to dual enum definitions:

1. **API Enum** (`family.py`): `RelationshipType` with values like `"breeding_partner"`
2. **Database Enum** (`family_models.py`): `RelationshipType` with same values but uppercase names

**Conversion Pattern**:

```python
# API enum to Database enum conversion
db_relationship_type = DBRelationshipType[relationship_type.value.upper()]

# Example: "breeding_partner" -> "BREEDING_PARTNER" -> DBRelationshipType.BREEDING_PARTNER
```

**Why `.upper()` is needed**:

- API enum value: `"breeding_partner"` (lowercase)
- Database enum name: `BREEDING_PARTNER` (uppercase)
- `DBRelationshipType["BREEDING_PARTNER"]` accesses enum by **name**, not value
- Alternative: `DBRelationshipType("breeding_partner")` accesses by **value**

**Database Query Pattern**:

```python
# CORRECT: Query the underlying string column
query.filter(BirdRelationship._relationship_type == relationship_type.value)

# INCORRECT: Query the property (causes filtering issues)
query.filter(BirdRelationship.relationship_type == relationship_type)
```

The `BirdRelationship.relationship_type` property converts between string and enum, but database queries must use the underlying `_relationship_type` column.

### API Routers

All routers follow consistent patterns:

- Prefix-based routing (`/sightings`, `/ringings`, etc.)
- Dependency injection for database sessions
- Proper HTTP status codes and error handling
- Pydantic models for request/response validation

## Environment Configuration

- Database URL via `DATABASE_URL` environment variable
- Logging level via `LOG_LEVEL`
- Testing mode via `TESTING` flag
- Environment file support with python-dotenv
